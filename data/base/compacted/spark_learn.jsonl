{"name":"absolute_value","location":{"path":"src/integer_utils.ads","subprogram_name":"Absolute_Value"},"prompt":"When I try to prove Absolute_Value, I get a warning that \"R\" might not be initialized and \"-X\" might overflow. Please can you make Absolute_Value provable.\n","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package body Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural) is\n   begin\n      if X < 0 then\n         R := -X;\n      end if;\n      if X >= 0 then\n         R := X;\n      end if;\n   end Absolute_Value;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural);\n\nend Integer_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package body Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural) is\n   begin\n      if X < 0 then\n         R := -X;\n      else\n         R := X;\n      end if;\n   end Absolute_Value;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural)\n   with Pre => X /= Integer'First;\n\nend Integer_Utils;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Integer_Utils; use Integer_Utils;\n\nprocedure Tests is\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Absolute_Value is\n      Result : Natural;\n   begin\n      Absolute_Value (1, Result);\n      pragma Assert (Result = 1, \"Expected 1, got \" & Result'Image);\n      Absolute_Value (-1, Result);\n      pragma Assert (Result = 1, \"Expected 1, got \" & Result'Image);\n      Absolute_Value (Integer'First + 1, Result);\n      pragma\n        Assert\n          (Result = Integer'Last,\n           \"Expected \" & Integer'Last'Image & \", got \" & Result'Image);\n   end Test_Absolute_Value;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Absolute_Value;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"in_out_init","location":{"path":"src/show_permutation.ads","subprogram_name":"Cyclic_Permutation"},"prompt":"When I run gnatprove against Cyclic_Permutation, I get a warning that \"A\" is not initialized. Please can you identify and fix the issue.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_permutation.adb":"package body Show_Permutation is\n\n   procedure Swap (A : in out Permutation; I, J : Positive) is\n      Tmp : Positive := A (I);\n   begin\n      A (I) := A (J);\n      A (J) := Tmp;\n   end Swap;\n\n   procedure Init (A : in out Permutation) is\n   begin\n      for I in A'First .. A'Last loop\n         A (I) := I;\n      end loop;\n   end Init;\n\n   function Cyclic_Permutation (N : Natural) return Permutation is\n      A : Permutation (1 .. N);\n   begin\n      Init (A);\n      for I in A'First .. A'Last - 1 loop\n         Swap (A, I, I + 1);\n      end loop;\n      return A;\n   end Cyclic_Permutation;\n\nend Show_Permutation;\n","src/show_permutation.ads":"package Show_Permutation is\n\n   type Permutation is array (Positive range <>) of Positive;\n\n   procedure Swap (A : in out Permutation; I, J : Positive);\n\n   procedure Init (A : in out Permutation);\n\n   function Cyclic_Permutation (N : Natural) return Permutation;\n\nend Show_Permutation;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_permutation.adb":"package body Show_Permutation is\n\n   procedure Swap (A : in out Permutation; I, J : Positive) is\n      Tmp : Positive := A (I);\n   begin\n      A (I) := A (J);\n      A (J) := Tmp;\n   end Swap;\n\n   procedure Init (A : out Permutation) is\n   begin\n      for I in A'First .. A'Last loop\n         A (I) := I;\n      end loop;\n   end Init;\n\n   function Cyclic_Permutation (N : Natural) return Permutation is\n      A : Permutation (1 .. N);\n   begin\n      Init (A);\n      for I in A'First .. A'Last - 1 loop\n         Swap (A, I, I + 1);\n      end loop;\n      return A;\n   end Cyclic_Permutation;\n\nend Show_Permutation;\n","src/show_permutation.ads":"package Show_Permutation is\n\n   type Permutation is array (Positive range <>) of Positive;\n\n   procedure Swap (A : in out Permutation; I, J : Positive);\n\n   procedure Init (A : out Permutation);\n\n   function Cyclic_Permutation (N : Natural) return Permutation;\n\nend Show_Permutation;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"The init procedure initializes an array, but the parameter is incorrectly marked as in out, instead of just out.","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Show_Permutation; use Show_Permutation;\n\nprocedure Tests is\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Swap is\n      Single_Item  : Permutation (1 .. 1) := [1];\n      Longer_Array : Permutation := [1, 2, 3, 4, 5];\n   begin\n      Swap (Single_Item, 1, 1);\n      pragma\n        Assert (Single_Item (1) = 1, \"Expected [1], got \" & Single_Item'Image);\n      Swap (Longer_Array, Longer_Array'First, Longer_Array'Last);\n      pragma\n        Assert\n          (Longer_Array = [5, 2, 3, 4, 1],\n           \"Expected [5, 2, 3, 4, 1], got \" & Longer_Array'Image);\n   end Test_Swap;\n\n   procedure Test_Init is\n      Single_Item_1 : Permutation (1 .. 1);\n      Single_Item_2 : Permutation (Positive'Last .. Positive'Last);\n      Longer_Array  : Permutation (1 .. 5);\n      Empty_Array   : Permutation (1 .. 0);\n   begin\n      Init (Single_Item_1);\n      pragma\n        Assert\n          (Single_Item_1 = [1], \"Expected [1], got \" & Single_Item_1'Image);\n      Init (Single_Item_2);\n      pragma\n        Assert\n          (Single_Item_2 = [Positive'Last],\n           \"Expected [\"\n             & Positive'Last'Image\n             & \"], got \"\n             & Single_Item_2'Image);\n      Init (Longer_Array);\n      pragma\n        Assert\n          (Longer_Array = [1, 2, 3, 4, 5],\n           \"Expected [1, 2, 3, 4, 5], got \" & Longer_Array'Image);\n      Init (Empty_Array);\n      pragma\n        Assert\n          (Empty_Array'Length = 0,\n           \"Expected empty array, got length \" & Empty_Array'Length'Image);\n   end Test_Init;\n\n   procedure Test_Cyclic_Permutation is\n   begin\n      pragma\n        Assert\n          (Cyclic_Permutation (0) = [],\n           \"Expected [], got \" & Cyclic_Permutation (0)'Image);\n      pragma\n        Assert\n          (Cyclic_Permutation (1) = [1],\n           \"Expected [1], got \" & Cyclic_Permutation (1)'Image);\n      pragma\n        Assert\n          (Cyclic_Permutation (2) = [2, 1],\n           \"Expected [2, 1], got \" & Cyclic_Permutation (2)'Image);\n      pragma\n        Assert\n          (Cyclic_Permutation (3) = [2, 3, 1],\n           \"Expected [2, 3, 1], got \" & Cyclic_Permutation (3)'Image);\n      pragma\n        Assert\n          (Cyclic_Permutation (10) = [2, 3, 4, 5, 6, 7, 8, 9, 10, 1],\n           \"Expected [2, 3, 4, 5, 6, 7, 8, 9, 10, 1], got \"\n             & Cyclic_Permutation (10)'Image);\n   end Test_Cyclic_Permutation;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Swap;\n   Test_Init;\n   Test_Cyclic_Permutation;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"ineffective_statements_1","location":{"path":"src/show_ineffective_statements.ads","subprogram_name":"Swap1"},"prompt":"When I try to prove Swap1, I get a warning about an unused initial value of \"X\". Please can you help me prove Swap1.\n","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap1 (X, Y : in out T) is\n      Tmp : T;\n   begin\n      Tmp := X;\n      X := Y;\n      Y := X;\n   end Swap1;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap1 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap1 (X, Y : in out T) is\n      Tmp : T := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap1;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap1 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Show_Ineffective_Statements; use Show_Ineffective_Statements;\n\nprocedure Tests is\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Swap1 is\n      X1, Y1 : T := 1;\n      X2     : T := 2;\n      Y2     : T := 3;\n      X3     : T := T'First;\n      Y3     : T := T'Last;\n   begin\n      Swap1 (X1, Y1);\n      pragma Assert (X1 = 1 and Y1 = 1, \"Should have no effect\");\n      Swap1 (X2, Y2);\n      pragma Assert (X2 = 3 and Y2 = 2, \"Simple swap\");\n      Swap1 (X3, Y3);\n      pragma Assert (X3 = T'Last and Y3 = T'First, \"Extreme values\");\n   end Test_Swap1;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Swap1;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"ineffective_statements_2","location":{"path":"src/show_ineffective_statements.ads","subprogram_name":"Swap2"},"prompt":"When I try to prove Swap2, I get a warning about an unused initial value of \"X\". Please can you help me prove Swap2.\n","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   Tmp : T := 0;\n\n   procedure Swap2 (X, Y : in out T) is\n      Temp : T := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap2;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap2 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap2 (X, Y : in out T) is\n      Tmp : T := Y;\n   begin\n      Y := X;\n      X := Tmp;\n   end Swap2;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap2 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Show_Ineffective_Statements; use Show_Ineffective_Statements;\n\nprocedure Tests is\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Swap2 is\n      X1, Y1 : T := 1;\n      X2     : T := 2;\n      Y2     : T := 3;\n      X3     : T := T'First;\n      Y3     : T := T'Last;\n   begin\n      Swap2 (X1, Y1);\n      pragma Assert (X1 = 1 and Y1 = 1, \"Should have no effect\");\n      Swap2 (X2, Y2);\n      pragma Assert (X2 = 3 and Y2 = 2, \"Simple swap\");\n      Swap2 (X3, Y3);\n      pragma Assert (X3 = T'Last and Y3 = T'First, \"Extreme values\");\n   end Test_Swap2;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Swap2;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"max_array","location":{"path":"src/array_utils.ads","subprogram_name":"Max_Array"},"prompt":"I'm trying to prove the correctness of Max_Array. With that in mind I've added a postcondition that states that the result is greater than or equal to all elements in the array, however gnatprove isn't able to prove this. Please can you help me make this provable, without removing the postcondition?","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural\n   with\n     Pre  => A'Length > 0,\n     Post => (for all I in A'Range => Max_Array'Result >= A (I));\n\nend Array_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         pragma\n           Loop_Invariant\n             (if I = A'First\n                then True\n                else (for all J in A'First .. I - 1 => Max >= A (J)));\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural\n   with\n     Pre  => A'Length > 0,\n     Post => (for all I in A'Range => Max_Array'Result >= A (I));\n\nend Array_Utils;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\nwith Ada.Numerics.Discrete_Random;\n\nwith Array_Utils; use Array_Utils;\n\nprocedure Tests is\n\n   procedure Shuffle_Array (Arr : in out Array_Utils.Array_Of_Naturals) is\n      subtype Array_Index is Integer range Arr'Range;\n      package Random_Index is new Ada.Numerics.Discrete_Random (Array_Index);\n      use Random_Index;\n\n      G          : Generator;\n      Temp       : Natural;\n      Random_Idx : Integer;\n   begin\n      Reset (G);\n\n      -- Fisher-Yates shuffle\n      for I in reverse Arr'Range loop\n         Random_Idx := Random (G, Arr'First, Arr'Last);\n         Temp := Arr (I);\n         Arr (I) := Arr (Random_Idx);\n         Arr (Random_Idx) := Temp;\n      end loop;\n   end Shuffle_Array;\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Max_Array is\n      Arr1       : constant Array_Of_Naturals := [1];\n      Arr2       : constant Array_Of_Naturals :=\n        [Natural'First, Natural'First + 1];\n      Arr3       : constant Array_Of_Naturals := [Natural'Last, Natural'First];\n      Arr4       : constant Array_Of_Naturals :=\n        [Natural'Last, 0, Natural'First];\n      Arr5       : Array_Of_Naturals (1 .. 10_000) :=\n        (for I in 1 .. 10_000 => I);\n      Arr6_First : constant Integer := Integer'Last - 9999;\n      Arr6       : Array_Of_Naturals (Arr6_First .. Integer'Last) :=\n        (for I in Arr6_First .. Integer'Last => I);\n      Res1       : constant Natural := Max_Array (Arr1);\n      Res2       : constant Natural := Max_Array (Arr2);\n      Res3       : constant Natural := Max_Array (Arr3);\n      Res4       : constant Natural := Max_Array (Arr4);\n      Res5       : Natural;\n      Res6       : Natural;\n   begin\n      Shuffle_Array (Arr5);\n      Res5 := Max_Array (Arr5);\n      Shuffle_Array (Arr6);\n      Res6 := Max_Array (Arr6);\n      pragma Assert (Res1 = 1, \"Single item\");\n      pragma Assert (Res2 = Natural'First + 1, \"Two small items\");\n      pragma Assert (Res3 = Natural'Last, \"Extreme values\");\n      pragma Assert (Res4 = Natural'Last, \"Three items\");\n      pragma Assert (Res5 = 10_000, \"Large array\");\n      pragma Assert (Res6 = Integer'Last, \"Large array\");\n   end Test_Max_Array;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Max_Array;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"search_array_1","location":{"path":"src/search_array.ads","subprogram_name":"Search_Array"},"prompt":"The implementation of Search_Array is correct, but gnatprove is unhappy, stating that an \"unexpected exception might be raised\". It's not unexpected. I expect it to be raised. Please can you help me fix the function specification to tell gnatprove that an exception might be raised.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer);\n\nend Search_Array;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer)\n   with Exceptional_Cases => (Not_Found => True);\n\nend Search_Array;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Search_Array; use Search_Array;\n\nprocedure Tests is\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Search_Array is\n      -- Test arrays\n      Large_Array         : Array_Of_Positives := (for I in 1 .. 1000 => I);\n      Unusual_Range_Array : constant Array_Of_Positives (10 .. 12) :=\n        [100, 200, 300];\n\n      Result : Integer;\n   begin\n\n      -- Find first element\n      Search_Array.Search_Array\n        (Large_Array, Large_Array (Large_Array'First), Result);\n      pragma\n        Assert\n          (Result = Large_Array'First, \"Should find element at the beginning\");\n\n      -- Find last element\n      Search_Array.Search_Array\n        (Large_Array, Large_Array (Large_Array'Last), Result);\n      pragma\n        Assert (Result = Large_Array'Last, \"Should find element at the end\");\n\n      -- Find middle element\n      Search_Array.Search_Array\n        (Unusual_Range_Array,\n         Unusual_Range_Array (Unusual_Range_Array'First + 1),\n         Result);\n      pragma\n        Assert\n          (Result = Unusual_Range_Array'First + 1,\n           \"Should find element in the middle\");\n\n      -- Find non-existing element\n      begin\n         Search_Array.Search_Array (Large_Array, 1001, Result);\n      exception\n         when Not_Found =>\n            return; -- expected exception\n      end;\n      raise Program_Error with \"exception Not_Found not raised as expected\";\n   end Test_Search_Array;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Search_Array;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"search_array_2","location":{"path":"src/search_array.ads","subprogram_name":"Contains"},"prompt":"When I try to prove Contains, I get a lot of warnings. While the implementation isn't the most efficient, I'm not allowed to change it at this point. Can you help me figure out how to make gnatprove without changing the actual implementation. (You can add any contracts/pragma's that would help though).","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean is\n      Result : Integer;\n   begin\n      Search_Array (A, E, Result);\n      pragma Unreferenced (Result);\n      return True;\n   exception\n      when Not_Found =>\n         return False;\n   end Contains;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer);\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean;\n\nend Search_Array;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean is\n      Result : Integer;\n   begin\n      Search_Array (A, E, Result);\n      pragma Unreferenced (Result);\n      return True;\n   exception\n      when Not_Found =>\n         return False;\n   end Contains;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer)\n   with Exceptional_Cases => (Not_Found => True);\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean;\n\nend Search_Array;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"This is basically the same as search_array_1, however if you try to prove Contains, gnatprove will output a bunch of warnings that might misdirect the user away from the actual issue.","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Search_Array; use Search_Array;\n\nprocedure Tests is\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Search_Array is\n      -- Test arrays\n      Large_Array         : Array_Of_Positives := (for I in 1 .. 1000 => I);\n      Unusual_Range_Array : constant Array_Of_Positives (10 .. 12) :=\n        [100, 200, 300];\n\n      Result : Integer;\n   begin\n\n      -- Find first element\n      Search_Array.Search_Array\n        (Large_Array, Large_Array (Large_Array'First), Result);\n      pragma\n        Assert\n          (Result = Large_Array'First, \"Should find element at the beginning\");\n\n      -- Find last element\n      Search_Array.Search_Array\n        (Large_Array, Large_Array (Large_Array'Last), Result);\n      pragma\n        Assert (Result = Large_Array'Last, \"Should find element at the end\");\n\n      -- Find middle element\n      Search_Array.Search_Array\n        (Unusual_Range_Array,\n         Unusual_Range_Array (Unusual_Range_Array'First + 1),\n         Result);\n      pragma\n        Assert\n          (Result = Unusual_Range_Array'First + 1,\n           \"Should find element in the middle\");\n\n      -- Find non-existing element\n      begin\n         Search_Array.Search_Array (Large_Array, 1001, Result);\n      exception\n         when Not_Found =>\n            return; -- expected exception\n      end;\n      raise Program_Error with \"exception Not_Found not raised as expected\";\n   end Test_Search_Array;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Search_Array;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"search_array_3","location":{"path":"src/search_array.ads","subprogram_name":"Search_Array"},"prompt":"Instead of raising an exception, can you modify the search function to use the new Search_Result type instead. The new implementation should be provable by gnatprove without warnings.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   type Search_Result (Found : Boolean := False) is record\n      case Found is\n         when True =>\n            Content : Integer;\n\n         when False =>\n            null;\n      end case;\n   end record;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result);\n\nend Search_Array;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := (Found => True, Content => I);\n            return;\n         end if;\n      end loop;\n      Result := (Found => False);\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   type Search_Result (Found : Boolean := False) is record\n      case Found is\n         when True =>\n            Content : Integer;\n\n         when False =>\n            null;\n      end case;\n   end record;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result)\n   with Pre => not Result'Constrained;\n\nend Search_Array;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"In this problem, the solution requires both updating the implementation correctly, as well as adding the correct pre-condition to the subprogram specification as well.","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Search_Array; use Search_Array;\n\nprocedure Tests is\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Search_Array is\n      -- Test arrays\n      Empty_Array         : constant Array_Of_Positives (1 .. 0) := [];\n      Large_Array         : Array_Of_Positives := (for I in 1 .. 1000 => I);\n      Unusual_Range_Array : constant Array_Of_Positives (10 .. 12) :=\n        [100, 200, 300];\n\n      Result : Search_Result;\n   begin\n      -- Find nothing in an empty array\n      Search_Array.Search_Array (Empty_Array, 1, Result);\n      pragma\n        Assert (Result.Found = False, \"Should't find element in empty array\");\n\n      -- Find first element\n      Search_Array.Search_Array\n        (Large_Array, Large_Array (Large_Array'First), Result);\n      pragma\n        Assert (Result.Found = True, \"Should find element at the beginning\");\n      pragma\n        Assert\n          (Result.Content = Large_Array'First,\n           \"Should find element at the beginning\");\n\n      -- Find last element\n      Search_Array.Search_Array\n        (Large_Array, Large_Array (Large_Array'Last), Result);\n      pragma Assert (Result.Found = True, \"Should find element at the end\");\n      pragma\n        Assert\n          (Result.Content = Large_Array'Last,\n           \"Should find element at the end\");\n\n      -- Find middle element\n      Search_Array.Search_Array\n        (Unusual_Range_Array,\n         Unusual_Range_Array (Unusual_Range_Array'First + 1),\n         Result);\n      pragma Assert (Result.Found = True, \"Should find element in the middle\");\n      pragma\n        Assert\n          (Result.Content = Unusual_Range_Array'First + 1,\n           \"Should find element in the middle\");\n   end Test_Search_Array;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Search_Array;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"show_modularity","location":{"path":"src/integer_utils.ads","subprogram_name":"Increment_Twice"},"prompt":"I'm trying to prove the absence of runtime errors for Increment_Twice. Please can you help me do this without changing the functionality of the code.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package body Integer_Utils is\n\n   procedure Increment (X : in out Integer) is\n   begin\n      X := X + 1;\n   end Increment;\n\n   procedure Increment_Twice (X : in out Integer) is\n   begin\n      Increment (X);\n      Increment (X);\n   end Increment_Twice;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Increment (X : in out Integer)\n   with Pre => X < Integer'Last;\n\n   procedure Increment_Twice (X : in out Integer)\n   with Pre => X < Integer'Last - 1;\n\nend Integer_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package body Integer_Utils is\n\n   procedure Increment (X : in out Integer) is\n   begin\n      X := X + 1;\n   end Increment;\n\n   procedure Increment_Twice (X : in out Integer) is\n   begin\n      Increment (X);\n      Increment (X);\n   end Increment_Twice;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Increment (X : in out Integer)\n   with Pre => X < Integer'Last, Post => X = X'Old + 1;\n\n   procedure Increment_Twice (X : in out Integer)\n   with Pre => X < Integer'Last - 1, Post => X = X'Old + 2;\n\nend Integer_Utils;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"Adapted from https://learn.adacore.com/courses/intro-to-spark/chapters/03_Proof_Of_Program_Integrity.html#modularity","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\nwith Ada.Numerics.Discrete_Random;\n\nwith Integer_Utils; use Integer_Utils;\n\nprocedure Tests is\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Increment is\n      X : Integer := 0;\n   begin\n      Increment (X);\n      pragma Assert (X = 1);\n      Increment_Twice (X);\n      pragma Assert (X = 3);\n      X := Integer'Last - 1;\n      Increment (X);\n      pragma Assert (X = Integer'Last);\n      X := Integer'First;\n      Increment_Twice (X);\n      pragma Assert (X = Integer'First + 2);\n   end Test_Increment;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Increment;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"show_post_condition_violation","location":{"path":"src/integer_utils.ads","subprogram_name":"Absolute"},"prompt":"I'm trying to prove the absence of runtime errors for Absolute. Please can make this provable.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package body Integer_Utils is\n\n   procedure Absolute (X : in out Integer) is\n   begin\n      if X > 0 then\n         X := -X;\n      end if;\n   end Absolute;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute (X : in out Integer)\n   with Post => X >= 0;\n\nend Integer_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package body Integer_Utils is\n\n   procedure Absolute (X : in out Integer) is\n   begin\n      X := abs X;\n   end Absolute;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute (X : in out Integer)\n   with Pre => X /= Integer'First, Post => X >= 0;\n\nend Integer_Utils;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"Adapted from https://learn.adacore.com/courses/intro-to-spark/chapters/03_Proof_Of_Program_Integrity.html#contracts","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\nwith Ada.Numerics.Discrete_Random;\n\nwith Integer_Utils; use Integer_Utils;\n\nprocedure Tests is\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Absolute is\n      X : Integer := 0;\n   begin\n      Absolute (X);\n      pragma Assert (X = 0);\n      X := -3;\n      Absolute (X);\n      pragma Assert (X = 3);\n      Absolute (X);\n      pragma Assert (X = 3);\n      X := Integer'First + 1;\n      Absolute (X);\n      pragma Assert (X = Integer'Last);\n      Absolute (X);\n      pragma Assert (X = Integer'Last);\n   end Test_Absolute;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Absolute;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"show_runtime_errors","location":{"path":"src/array_utils.ads","subprogram_name":"Update"},"prompt":"I'm trying to prove the absence of runtime errors for Update. Please can you help me do this without changing the functionality of the code.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   procedure Update (A : in out Nat_Array; I, J, P, Q : Integer) is\n   begin\n      A (I + J) := P / Q;\n   end Update;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Nat_Array is array (Integer range <>) of Natural;\n\n   procedure Update (A : in out Nat_Array; I, J, P, Q : Integer);\n\nend Array_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   procedure Update (A : in out Nat_Array; I, J, P, Q : Integer) is\n   begin\n      A (I + J) := P / Q;\n   end Update;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Nat_Array is array (Integer range <>) of Natural;\n\n   procedure Update (A : in out Nat_Array; I, J, P, Q : Integer)\n   with\n     Pre =>\n       ((if I >= 0 and J >= 0\n         then I <= Integer'Last - J\n         elsif I < 0 and J < 0\n         then I >= Integer'First - J\n         else True)  -- Check that I + J does not overflow\n        and then I + J in A'Range  -- Check that I + J is an index in A\n        and then Q /= 0  -- So there can't be a division by zero\n        and then not (P = Integer'First\n                      and Q = -1)  -- As abs Integer'First is out of range\n        and then P / Q >= 1);  -- Ensure P / Q is a natural number\n\nend Array_Utils;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"Adapted from https://learn.adacore.com/courses/intro-to-spark/chapters/03_Proof_Of_Program_Integrity.html#runtime-errors","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\nwith Ada.Numerics.Discrete_Random;\n\nwith Array_Utils; use Array_Utils;\n\nprocedure Tests is\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Update is\n      A1 : Nat_Array := [1 => 1];\n      A2 : Nat_Array (11 .. 20) := [for I in 1 .. 10 => I];\n   begin\n      Update (A1, 0, 1, 8, 4);\n      pragma Assert (A1 = [2]);\n      Update (A1, -1000, 1001, 245273732, 197324);\n      pragma Assert (A1 = [1243]);\n      Update (A2, -5, 20, 64, 4);\n      pragma Assert (A2 = [1, 2, 3, 4, 16, 6, 7, 8, 9, 10]);\n   end Test_Update;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Update;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"show_uninitialized","location":{"path":"src/array_utils.ads","subprogram_name":"Max_Array"},"prompt":"Please can you help me prove the implementation of Max_Array.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural;\n\nend Array_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural;\n\nend Array_Utils;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\nwith Ada.Numerics.Discrete_Random;\n\nwith Array_Utils; use Array_Utils;\n\nprocedure Tests is\n\n   procedure Shuffle_Array (Arr : in out Array_Utils.Array_Of_Naturals) is\n      subtype Array_Index is Integer range Arr'Range;\n      package Random_Index is new Ada.Numerics.Discrete_Random (Array_Index);\n      use Random_Index;\n\n      G          : Generator;\n      Temp       : Natural;\n      Random_Idx : Integer;\n   begin\n      Reset (G);\n\n      -- Fisher-Yates shuffle\n      for I in reverse Arr'Range loop\n         Random_Idx := Random (G, Arr'First, Arr'Last);\n         Temp := Arr (I);\n         Arr (I) := Arr (Random_Idx);\n         Arr (Random_Idx) := Temp;\n      end loop;\n   end Shuffle_Array;\n\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Max_Array is\n      Arr1       : constant Array_Of_Naturals := [1];\n      Arr2       : constant Array_Of_Naturals :=\n        [Natural'First, Natural'First + 1];\n      Arr3       : constant Array_Of_Naturals := [Natural'Last, Natural'First];\n      Arr4       : constant Array_Of_Naturals :=\n        [Natural'Last, 0, Natural'First];\n      Arr5       : Array_Of_Naturals (1 .. 10_000) :=\n        (for I in 1 .. 10_000 => I);\n      Arr6_First : constant Integer := Integer'Last - 9999;\n      Arr6       : Array_Of_Naturals (Arr6_First .. Integer'Last) :=\n        (for I in Arr6_First .. Integer'Last => I);\n      Res1       : constant Natural := Max_Array (Arr1);\n      Res2       : constant Natural := Max_Array (Arr2);\n      Res3       : constant Natural := Max_Array (Arr3);\n      Res4       : constant Natural := Max_Array (Arr4);\n      Res5       : Natural;\n      Res6       : Natural;\n   begin\n      Shuffle_Array (Arr5);\n      Res5 := Max_Array (Arr5);\n      Shuffle_Array (Arr6);\n      Res6 := Max_Array (Arr6);\n      pragma Assert (Res1 = 1, \"Single item\");\n      pragma Assert (Res2 = Natural'First + 1, \"Two small items\");\n      pragma Assert (Res3 = Natural'Last, \"Extreme values\");\n      pragma Assert (Res4 = Natural'Last, \"Three items\");\n      pragma Assert (Res5 = 10_000, \"Large array\");\n      pragma Assert (Res6 = Integer'Last, \"Large array\");\n   end Test_Max_Array;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Max_Array;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
{"name":"swap_depends","location":{"path":"src/show_swap.ads","subprogram_name":"Identity"},"prompt":"GNATprove complains about the Depends clause on the Identity procedure. Please can you help me make this provable, without removing the Depends clause?","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_swap.adb":"package body Show_Swap is\n\n   procedure Swap (X, Y : in out Positive) is\n      Tmp : constant Positive := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap;\n\n   procedure Identity (X, Y : in out Positive) is\n   begin\n      Swap (X => X, Y => Y);\n      Swap (X => Y, Y => X);\n   end Identity;\n\nend Show_Swap;\n","src/show_swap.ads":"package Show_Swap is\n\n   procedure Swap (X, Y : in out Positive);\n\n   procedure Identity (X, Y : in out Positive)\n   with Depends => (X => X, Y => Y);\n\nend Show_Swap;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\n   package Builder is\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_swap.adb":"package body Show_Swap is\n\n   procedure Swap (X, Y : in out Positive) is\n      Tmp : constant Positive := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap;\n\n   procedure Identity (X, Y : in out Positive) is\n   begin\n      Swap (X => X, Y => Y);\n      Swap (X => Y, Y => X);\n   end Identity;\n\nend Show_Swap;\n","src/show_swap.ads":"package Show_Swap is\n\n   procedure Swap (X, Y : in out Positive)\n   with Depends => (X => Y, Y => X);\n\n   procedure Identity (X, Y : in out Positive)\n   with Depends => (X => X, Y => Y);\n\nend Show_Swap;\n"},"canonical_evaluation_results":[{"eval":"build","compiled":true,"pre_format_warnings":false,"post_format_warnings":false},{"eval":"prove","successfully_proven":true,"subprogram_found":true},{"eval":"test","compiled":true,"passed_tests":true}],"comments":"","unit_tests":{"src/tests.adb":"with Ada.Assertions; use Ada.Assertions;\n\nwith Show_Swap; use Show_Swap;\n\nprocedure Tests is\n   procedure Check_Assertions_Enabled is\n   begin\n      begin\n         pragma Assert (False, \"Should raise\");\n      exception\n         when others =>\n            return; -- properly raised\n      end;\n      raise Program_Error with \"Assertions not enabled\";\n   end Check_Assertions_Enabled;\n\n   procedure Test_Swap is\n      X1, Y1 : Positive := 1;\n      X2     : Positive := 2;\n      Y2     : Positive := 3;\n      X3     : Positive := 1;\n      Y3     : Positive := Positive'Last;\n   begin\n      Swap (X1, Y1);\n      pragma Assert (X1 = 1 and Y1 = 1, \"Should have no effect\");\n      Swap (X2, Y2);\n      pragma Assert (X2 = 3 and Y2 = 2, \"Simple swap\");\n      Swap (X3, Y3);\n      pragma Assert (X3 = Positive'Last and Y3 = 1, \"Extreme values\");\n   end Test_Swap;\n\n   procedure Test_Identity is\n      X1, Y1 : Positive := 1;\n      X2     : Positive := 2;\n      Y2     : Positive := 3;\n      X3     : Positive := 1;\n      Y3     : Positive := Positive'Last;\n   begin\n      Identity (X1, Y1);\n      pragma Assert (X1 = 1 and Y1 = 1, \"Same values\");\n      Identity (X2, Y2);\n      pragma Assert (X2 = 2 and Y2 = 3, \"Simple identity\");\n      Identity (X3, Y3);\n      pragma Assert (X3 = 1 and Y3 = Positive'Last, \"Extreme values\");\n   end Test_Identity;\n\nbegin\n   Check_Assertions_Enabled;\n   Test_Swap;\n   Test_Identity;\nend Tests;\n","tests.gpr":"with \"main.gpr\";\n\nproject Tests is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Exec_Dir use \"bin\";\n   for Create_Missing_Dirs use \"True\";\n   for Main use (\"tests.adb\");\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\n         \"-g\"         -- Generate debug info\n         ,\"-gnata\"    -- Enable assertions and contracts\n         ,\"-gnatW8\"   -- UTF-8 encoding for wide characters\n         ,\"-gnat2022\" -- Use Ada 2022 features\n      );\n   end Compiler;\n\nend Tests;"}}
