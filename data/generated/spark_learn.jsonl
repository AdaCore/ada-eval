{"name":"absolute_value","location":{"path":"src/integer_utils.ads","subprogram_name":"Absolute_Value"},"prompt":"When I try to prove Absolute_Value, I get a warning that \"R\" might not be initialized. Please can you make Absolute_Value provable.\n","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural) is\n   begin\n      if X < 0 then\n         R := -X;\n      end if;\n      if X >= 0 then\n         R := X;\n      end if;\n   end Absolute_Value;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural);\n\nend Integer_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural) is\n   begin\n      if X < 0 then\n         R := -X;\n      else\n         R := X;\n      end if;\n   end Absolute_Value;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural);\n\nend Integer_Utils;\n"},"canonical_evaluation_results":[{"successfully_proven":false,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: When I try to prove Absolute_Value, I get a warning that \"R\" might not be initialized. Please can you make Absolute_Value provable.\n\nSleeping for 3 seconds to simulate processing...\n","stderr":"","runtime_ms":3006},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/integer_utils.adb":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural) is\n   begin\n      if X < 0 then\n         R := -X;\n      end if;\n      if X >= 0 then\n         R := X;\n      end if;\n   end Absolute_Value;\n\nend Integer_Utils;\n","src/integer_utils.ads":"package Integer_Utils is\n\n   procedure Absolute_Value (X : Integer; R : out Natural);\n\nend Integer_Utils;\n"},"unit_tests":{}}
{"name":"in_out_init","location":{"path":"src/show_permutation.ads","subprogram_name":"Cyclic_Permutation"},"prompt":"When I run gnatprove against Cyclic_Permutation, I get a warning that \"A\" is not initialized. Please can you identify and fix the issue.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_permutation.adb":"package body Show_Permutation is\n\n   procedure Swap (A : in out Permutation; I, J : Positive) is\n      Tmp : Positive := A (I);\n   begin\n      A (I) := A (J);\n      A (J) := Tmp;\n   end Swap;\n\n   procedure Init (A : in out Permutation) is\n   begin\n      for I in A'First .. A'Last loop\n         A (I) := I;\n      end loop;\n   end Init;\n\n   function Cyclic_Permutation (N : Natural) return Permutation is\n      A : Permutation (1 .. N);\n   begin\n      Init (A);\n      for I in A'First .. A'Last - 1 loop\n         Swap (A, I, I + 1);\n      end loop;\n      return A;\n   end Cyclic_Permutation;\n\nend Show_Permutation;\n","src/show_permutation.ads":"package Show_Permutation is\n\n   type Permutation is array (Positive range <>) of Positive;\n\n   procedure Swap (A : in out Permutation; I, J : Positive);\n\n   procedure Init (A : in out Permutation);\n\n   function Cyclic_Permutation (N : Natural) return Permutation;\n\nend Show_Permutation;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_permutation.adb":"package body Show_Permutation is\n\n   procedure Swap (A : in out Permutation; I, J : Positive) is\n      Tmp : Positive := A (I);\n   begin\n      A (I) := A (J);\n      A (J) := Tmp;\n   end Swap;\n\n   procedure Init (A : out Permutation) is\n   begin\n      for I in A'First .. A'Last loop\n         A (I) := I;\n      end loop;\n   end Init;\n\n   function Cyclic_Permutation (N : Natural) return Permutation is\n      A : Permutation (1 .. N);\n   begin\n      Init (A);\n      for I in A'First .. A'Last - 1 loop\n         Swap (A, I, I + 1);\n      end loop;\n      return A;\n   end Cyclic_Permutation;\n\nend Show_Permutation;\n","src/show_permutation.ads":"package Show_Permutation is\n\n   type Permutation is array (Positive range <>) of Positive;\n\n   procedure Swap (A : in out Permutation; I, J : Positive);\n\n   procedure Init (A : out Permutation);\n\n   function Cyclic_Permutation (N : Natural) return Permutation;\n\nend Show_Permutation;\n"},"canonical_evaluation_results":[{"successfully_proven":false,"timed_out":false}],"comments":"The init procedure initializes an array, but the parameter is incorrectly marked as in out, instead of just out.","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: When I run gnatprove against Cyclic_Permutation, I get a warning that \"A\" is not initialized. Please can you identify and fix the issue.\nSleeping for 3 seconds to simulate processing...\n","stderr":"","runtime_ms":3002},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_permutation.adb":"package body Show_Permutation is\n\n   procedure Swap (A : in out Permutation; I, J : Positive) is\n      Tmp : Positive := A (I);\n   begin\n      A (I) := A (J);\n      A (J) := Tmp;\n   end Swap;\n\n   procedure Init (A : in out Permutation) is\n   begin\n      for I in A'First .. A'Last loop\n         A (I) := I;\n      end loop;\n   end Init;\n\n   function Cyclic_Permutation (N : Natural) return Permutation is\n      A : Permutation (1 .. N);\n   begin\n      Init (A);\n      for I in A'First .. A'Last - 1 loop\n         Swap (A, I, I + 1);\n      end loop;\n      return A;\n   end Cyclic_Permutation;\n\nend Show_Permutation;\n","src/show_permutation.ads":"package Show_Permutation is\n\n   type Permutation is array (Positive range <>) of Positive;\n\n   procedure Swap (A : in out Permutation; I, J : Positive);\n\n   procedure Init (A : in out Permutation);\n\n   function Cyclic_Permutation (N : Natural) return Permutation;\n\nend Show_Permutation;\n"},"unit_tests":{}}
{"name":"ineffective_statements_1","location":{"path":"src/show_ineffective_statements.ads","subprogram_name":"Swap1"},"prompt":"When I try to prove Swap1, I get a warning about an unused initial value of \"X\". Please can you help me prove Swap1.\n","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap1 (X, Y : in out T) is\n      Tmp : T;\n   begin\n      Tmp := X;\n      X := Y;\n      Y := X;\n   end Swap1;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap1 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap1 (X, Y : in out T) is\n      Tmp : T := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap1;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap1 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: When I try to prove Swap1, I get a warning about an unused initial value of \"X\". Please can you help me prove Swap1.\n\nSleeping for 1 seconds to simulate processing...\n","stderr":"","runtime_ms":1003},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap1 (X, Y : in out T) is\n      Tmp : T;\n   begin\n      Tmp := X;\n      X := Y;\n      Y := X;\n   end Swap1;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap1 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"unit_tests":{}}
{"name":"ineffective_statements_2","location":{"path":"src/show_ineffective_statements.ads","subprogram_name":"Swap2"},"prompt":"When I try to prove Swap2, I get a warning about an unused initial value of \"X\". Please can you help me prove Swap2.\n","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   Tmp : T := 0;\n\n   procedure Swap2 (X, Y : in out T) is\n      Temp : T := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap2;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap2 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   procedure Swap2 (X, Y : in out T) is\n      Tmp : T := Y;\n   begin\n      Y := X;\n      X := Tmp;\n   end Swap2;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap2 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: When I try to prove Swap2, I get a warning about an unused initial value of \"X\". Please can you help me prove Swap2.\n\nSleeping for 2 seconds to simulate processing...\n","stderr":"","runtime_ms":2003},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_ineffective_statements.adb":"package body Show_Ineffective_Statements is\n\n   Tmp : T := 0;\n\n   procedure Swap2 (X, Y : in out T) is\n      Temp : T := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap2;\n\nend Show_Ineffective_Statements;\n","src/show_ineffective_statements.ads":"package Show_Ineffective_Statements is\n\n   type T is new Integer;\n\n   procedure Swap2 (X, Y : in out T);\n\nend Show_Ineffective_Statements;\n"},"unit_tests":{}}
{"name":"max_array","location":{"path":"src/array_utils.ads","subprogram_name":"Max_Array"},"prompt":"I'm trying to prove the correctness of Max_Array. With that in mind I've added a postcondition that states that the result is greater than or equal to all elements in the array, however gnatprove isn't able to prove this. Please can you help me make this provable, without removing the postcondition?","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural\n   with\n     Pre  => A'Length > 0,\n     Post => (for all I in A'Range => Max_Array'Result >= A (I));\n\nend Array_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         pragma\n           Loop_Invariant\n             (if I = A'First\n                then True\n                else (for all J in A'First .. I - 1 => Max >= A (J)));\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural\n   with\n     Pre  => A'Length > 0,\n     Post => (for all I in A'Range => Max_Array'Result >= A (I));\n\nend Array_Utils;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: I'm trying to prove the correctness of Max_Array. With that in mind I've added a postcondition that states that the result is greater than or equal to all elements in the array, however gnatprove isn't able to prove this. Please can you help me make this provable, without removing the postcondition?\nSleeping for 3 seconds to simulate processing...\n","stderr":"","runtime_ms":3003},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural\n   with\n     Pre  => A'Length > 0,\n     Post => (for all I in A'Range => Max_Array'Result >= A (I));\n\nend Array_Utils;\n"},"unit_tests":{}}
{"name":"search_array_1","location":{"path":"src/search_array.ads","subprogram_name":"Search_Array"},"prompt":"The implementation of Search_Array is correct, but gnatprove is unhappy, stating that an \"unexpected exception might be raised\". It's not unexpected. I expect it to be raised. Please can you help me fix the function specification to tell gnatprove that an exception might be raised.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer);\n\nend Search_Array;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer)\n   with Exceptional_Cases => (Not_Found => True);\n\nend Search_Array;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: The implementation of Search_Array is correct, but gnatprove is unhappy, stating that an \"unexpected exception might be raised\". It's not unexpected. I expect it to be raised. Please can you help me fix the function specification to tell gnatprove that an exception might be raised.\nSleeping for 2 seconds to simulate processing...\n","stderr":"","runtime_ms":2004},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer);\n\nend Search_Array;\n"},"unit_tests":{}}
{"name":"search_array_2","location":{"path":"src/search_array.ads","subprogram_name":"Contains"},"prompt":"When I try to prove Contains, I get a lot of warnings. While the implementation isn't the most efficient, I'm not allowed to change it at this point. Can you help me figure out how to make gnatprove without changing the actual implementation. (You can add any contracts/pragma's that would help though).","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean is\n      Result : Integer;\n   begin\n      Search_Array (A, E, Result);\n      pragma Unreferenced (Result);\n      return True;\n   exception\n      when Not_Found =>\n         return False;\n   end Contains;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer);\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean;\n\nend Search_Array;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean is\n      Result : Integer;\n   begin\n      Search_Array (A, E, Result);\n      pragma Unreferenced (Result);\n      return True;\n   exception\n      when Not_Found =>\n         return False;\n   end Contains;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer)\n   with Exceptional_Cases => (Not_Found => True);\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean;\n\nend Search_Array;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"This is basically the same as search_array_1, however if you try to prove Contains, gnatprove will output a bunch of warnings that might misdirect the user away from the actual issue.","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: When I try to prove Contains, I get a lot of warnings. While the implementation isn't the most efficient, I'm not allowed to change it at this point. Can you help me figure out how to make gnatprove without changing the actual implementation. (You can add any contracts/pragma's that would help though).\nSleeping for 1 seconds to simulate processing...\n","stderr":"","runtime_ms":1002},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean is\n      Result : Integer;\n   begin\n      Search_Array (A, E, Result);\n      pragma Unreferenced (Result);\n      return True;\n   exception\n      when Not_Found =>\n         return False;\n   end Contains;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer);\n\n   function Contains (A : Array_Of_Positives; E : Positive) return Boolean;\n\nend Search_Array;\n"},"unit_tests":{}}
{"name":"search_array_3","location":{"path":"src/search_array.ads","subprogram_name":"Search_Array"},"prompt":"Instead of raising an exception, can you modify the search function to use the new Search_Result type instead. The new implementation should be provable by gnatprove without warnings.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   type Search_Result (Found : Boolean := False) is record\n      case Found is\n         when True =>\n            Content : Integer;\n\n         when False =>\n            null;\n      end case;\n   end record;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result);\n\nend Search_Array;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := (Found => True, Content => I);\n            return;\n         end if;\n      end loop;\n      Result := (Found => False);\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   type Search_Result (Found : Boolean := False) is record\n      case Found is\n         when True =>\n            Content : Integer;\n\n         when False =>\n            null;\n      end case;\n   end record;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result)\n   with Pre => not Result'Constrained;\n\nend Search_Array;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"In this problem, the solution requires both updating the implementation correctly, as well as adding the correct pre-condition to the subprogram specification as well.","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: Instead of raising an exception, can you modify the search function to use the new Search_Result type instead. The new implementation should be provable by gnatprove without warnings.\nSleeping for 3 seconds to simulate processing...\n","stderr":"","runtime_ms":3002},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/search_array.adb":"package body Search_Array is\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Integer) is\n   begin\n      for I in A'Range loop\n         if A (I) = E then\n            Result := I;\n            return;\n         end if;\n      end loop;\n      raise Not_Found;\n   end Search_Array;\n\nend Search_Array;\n","src/search_array.ads":"package Search_Array is\n\n   type Array_Of_Positives is array (Natural range <>) of Positive;\n\n   Not_Found : exception;\n\n   type Search_Result (Found : Boolean := False) is record\n      case Found is\n         when True =>\n            Content : Integer;\n\n         when False =>\n            null;\n      end case;\n   end record;\n\n   procedure Search_Array\n     (A : Array_Of_Positives; E : Positive; Result : out Search_Result);\n\nend Search_Array;\n"},"unit_tests":{}}
{"name":"show_uninitialized","location":{"path":"src/array_utils.ads","subprogram_name":"Max_Array"},"prompt":"Please can you help me prove the implementation of Max_Array.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural;\n\nend Array_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural := Natural'First;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural;\n\nend Array_Utils;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: Please can you help me prove the implementation of Max_Array.\nSleeping for 1 seconds to simulate processing...\n","stderr":"","runtime_ms":1003},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/array_utils.adb":"package body Array_Utils is\n\n   function Max_Array (A : Array_Of_Naturals) return Natural is\n      Max : Natural;\n   begin\n      for I in A'Range loop\n         if A (I) > Max then\n            Max := A (I);\n         end if;\n      end loop;\n      return Max;\n   end Max_Array;\n\nend Array_Utils;\n","src/array_utils.ads":"package Array_Utils is\n\n   type Array_Of_Naturals is array (Integer range <>) of Natural;\n\n   function Max_Array (A : Array_Of_Naturals) return Natural;\n\nend Array_Utils;\n"},"unit_tests":{}}
{"name":"swap_depends","location":{"path":"src/show_swap.ads","subprogram_name":"Identity"},"prompt":"GNATprove complains about the Depends clause on the Identity procedure. Please can you help me make this provable, without removing the Depends clause?","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_swap.adb":"package body Show_Swap is\n\n   procedure Swap (X, Y : in out Positive) is\n      Tmp : constant Positive := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap;\n\n   procedure Identity (X, Y : in out Positive) is\n   begin\n      Swap (X, Y);\n      Swap (Y, X);\n   end Identity;\n\nend Show_Swap;\n","src/show_swap.ads":"package Show_Swap is\n\n   procedure Swap (X, Y : in out Positive);\n\n   procedure Identity (X, Y : in out Positive)\n   with Depends => (X => X, Y => Y);\n\nend Show_Swap;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_swap.adb":"package body Show_Swap is\n\n   procedure Swap (X, Y : in out Positive) is\n      Tmp : constant Positive := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap;\n\n   procedure Identity (X, Y : in out Positive) is\n   begin\n      Swap (X, Y);\n      Swap (Y, X);\n   end Identity;\n\nend Show_Swap;\n","src/show_swap.ads":"package Show_Swap is\n\n   procedure Swap (X, Y : in out Positive)\n   with Depends => (X => Y, Y => X);\n\n   procedure Identity (X, Y : in out Positive)\n   with Depends => (X => X, Y => Y);\n\nend Show_Swap;\n"},"canonical_evaluation_results":[{"successfully_proven":true,"timed_out":false}],"comments":"","generation_stats":{"exit_code":0,"stdout":"Dummy script executed with prompt: GNATprove complains about the Depends clause on the Identity procedure. Please can you help me make this provable, without removing the Depends clause?\nSleeping for 3 seconds to simulate processing...\n","stderr":"","runtime_ms":3003},"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/show_swap.adb":"package body Show_Swap is\n\n   procedure Swap (X, Y : in out Positive) is\n      Tmp : constant Positive := X;\n   begin\n      X := Y;\n      Y := Tmp;\n   end Swap;\n\n   procedure Identity (X, Y : in out Positive) is\n   begin\n      Swap (X, Y);\n      Swap (Y, X);\n   end Identity;\n\nend Show_Swap;\n","src/show_swap.ads":"package Show_Swap is\n\n   procedure Swap (X, Y : in out Positive);\n\n   procedure Identity (X, Y : in out Positive)\n   with Depends => (X => X, Y => Y);\n\nend Show_Swap;\n"},"unit_tests":{}}
