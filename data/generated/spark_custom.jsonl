{"sample":{"name":"char_count_1","location":{"path":"src/string_utils.ads","start":{"line":3,"column":null},"end":null},"prompt":"Please can you help me prove the count function in `src/string_utils.ads`.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnat2022\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/string_utils.adb":"package body String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural is\n      Result : Natural := 0;\n   begin\n      for I in Str'Range loop\n         if Str (I) = Char then\n            Result := Result + 1;\n         end if;\n      end loop;\n      return Result;\n   end Count;\n\nend String_Utils;\n","src/string_utils.ads":"package String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural;\n\nend String_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnat2022\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/string_utils.adb":"package body String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural is\n      Result : Natural := 0;\n   begin\n      for I in Str'Range loop\n         pragma Loop_Invariant (Result <= I - Str'First);\n         if Str (I) = Char then\n            Result := Result + 1;\n         end if;\n      end loop;\n      return Result;\n   end Count;\n\nend String_Utils;\n","src/string_utils.ads":"package String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural;\n\nend String_Utils;\n"},"comments":"","location_solution":null,"unit_tests":{}},"result":{"exit_code":0,"stdout":"The SPARK annotations will allow gnatprove to formally verify that:\n\n1. The function always returns a value â‰¤ the input string length\n2. The loop correctly counts characters without overflow\n3. The implementation satisfies the specification\n\nYou can now run `gnatprove -P main.gpr --level=2` to verify the proofs. The key insight is that since we only increment `Result` when we find a matching character, and we can only increment it once per character in the string, `Result` can never exceed `Str'Length`.\n","stderr":"","runtime_ms":66831,"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnat2022\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/string_utils.adb":"package body String_Utils\n  with SPARK_Mode => On\nis\n\n   function Count (Str : String; Char : Character) return Natural is\n      Result : Natural := 0;\n   begin\n      for I in Str'Range loop\n         pragma Loop_Invariant (Result <= I - Str'First);\n         pragma Loop_Invariant (Result <= Str'Length);\n         \n         if Str (I) = Char then\n            Result := Result + 1;\n         end if;\n      end loop;\n      \n      pragma Assert (Result <= Str'Length);\n      return Result;\n   end Count;\n\nend String_Utils;\n","src/string_utils.ads":"package String_Utils\n  with SPARK_Mode => On\nis\n\n   function Count (Str : String; Char : Character) return Natural\n     with\n       Post => Count'Result <= Str'Length;\n\nend String_Utils;\n"}}}
{"sample":{"name":"char_count_2","location":{"path":"src/string_utils.ads","start":{"line":12,"column":null},"end":null},"prompt":"Please can you help me prove the count function in `src/string_utils.ads`.","sources":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnat2022\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/string_utils.adb":"package body String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural is\n      Result : Natural := 0;\n   begin\n      for I in Str'Range loop\n         if Str (I) = Char then\n            Result := Result + 1;\n         end if;\n      end loop;\n      return Result;\n   end Count;\n\nend String_Utils;\n","src/string_utils.ads":"package String_Utils is\n\n   function Count_Ghost\n     (Str : String; Char : Character; Idx : Integer) return Natural\n   is (if Idx not in Str'Range\n       then 0\n       else\n         (if Str (Idx) = Char\n          then 1 + Count_Ghost (Str, Char, Idx - 1)\n          else 0 + Count_Ghost (Str, Char, Idx - 1)));\n\n   function Count (Str : String; Char : Character) return Natural\n   with Post => Count'Result = Count_Ghost (Str, Char, Str'Last);\n\nend String_Utils;\n"},"canonical_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnat2022\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/string_utils.adb":"package body String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural is\n      Result : Natural := 0;\n   begin\n      for I in Str'Range loop\n         pragma Loop_Invariant (Result <= I - Str'First);\n         pragma Loop_Invariant (Result = Count_Ghost (Str, Char, I - 1));\n         if Str (I) = Char then\n            Result := Result + 1;\n         end if;\n      end loop;\n      return Result;\n   end Count;\n\nend String_Utils;\n","src/string_utils.ads":"package String_Utils is\n\n   function Count_Ghost\n     (Str : String; Char : Character; Idx : Integer) return Natural\n   is (if Idx not in Str'Range\n       then 0\n       else\n         (if Str (Idx) = Char\n          then 1 + Count_Ghost (Str, Char, Idx - 1)\n          else 0 + Count_Ghost (Str, Char, Idx - 1)))\n   with\n     Ghost,\n     Post               =>\n       (if Idx not in Str'Range\n        then Count_Ghost'Result = 0\n        else Count_Ghost'Result <= (Idx - Str'First) + 1),\n     Subprogram_Variant => (Decreases => Idx);\n\n   function Count (Str : String; Char : Character) return Natural\n   with Post => Count'Result = Count_Ghost (Str, Char, Str'Last);\n\nend String_Utils;\n"},"comments":"","location_solution":{"path":"src/string_utils.ads","start":{"line":19,"column":null},"end":null},"unit_tests":{}},"result":{"exit_code":0,"stdout":"I've successfully added the necessary proof annotations to the Count function in `src/string_utils.adb:7-8`. The key addition is the loop invariant:\n\n```ada\npragma Loop_Invariant (Result = Count_Ghost (Str, Char, I - 1));\n```\n\nThis invariant establishes that at each iteration, the accumulated `Result` equals what the ghost function `Count_Ghost` would return for the substring processed so far (up to index `I - 1`). Combined with the existing postcondition, this should allow SPARK to prove the function's correctness.\n\nThe proof works because:\n1. The loop invariant relates the iterative computation to the recursive ghost function\n2. The postcondition requires `Count'Result = Count_Ghost (Str, Char, Str'Last)`\n3. When the loop completes, `I - 1` equals `Str'Last`, satisfying the postcondition\n","stderr":"","runtime_ms":53203,"generated_solution":{"main.adc":"pragma SPARK_Mode (On);","main.gpr":"project Main is\n   for Languages use (\"Ada\");\n\n   for Source_Dirs use (\"src\");\n   for Object_Dir use \"obj\";\n   for Create_Missing_Dirs use \"True\";\n\n   package Compiler is\n      for Default_Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnat2022\");\n      for Switches (\"Ada\") use (\"-gnata\");\n   end Compiler;\n\n   package Builder is\n      for Default_Switches (\"Ada\") use (\"-g\");\n      for Switches (\"Ada\") use (\"-gnata\");\n      for Global_Configuration_Pragmas use \"main.adc\";\n   end Builder;\n\nend Main;","src/string_utils.adb":"package body String_Utils is\n\n   function Count (Str : String; Char : Character) return Natural is\n      Result : Natural := 0;\n   begin\n      for I in Str'Range loop\n         pragma Loop_Invariant\n           (Result = Count_Ghost (Str, Char, I - 1));\n         if Str (I) = Char then\n            Result := Result + 1;\n         end if;\n      end loop;\n      return Result;\n   end Count;\n\nend String_Utils;\n","src/string_utils.ads":"package String_Utils is\n\n   function Count_Ghost\n     (Str : String; Char : Character; Idx : Integer) return Natural\n   is (if Idx not in Str'Range\n       then 0\n       else\n         (if Str (Idx) = Char\n          then 1 + Count_Ghost (Str, Char, Idx - 1)\n          else 0 + Count_Ghost (Str, Char, Idx - 1)));\n\n   function Count (Str : String; Char : Character) return Natural\n   with Post => Count'Result = Count_Ghost (Str, Char, Str'Last);\n\nend String_Utils;\n"}}}
